{"version":3,"file":"index.js","sources":["../webpack://dagster-cloud-cicd-action/./src/dagsterCloud.js","../webpack://dagster-cloud-cicd-action/../../.nvm/versions/node/v16.6.0/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://dagster-cloud-cicd-action/external \"fs\"","../webpack://dagster-cloud-cicd-action/external \"os\"","../webpack://dagster-cloud-cicd-action/external \"path\"","../webpack://dagster-cloud-cicd-action/external \"util\"","../webpack://dagster-cloud-cicd-action/webpack/bootstrap","../webpack://dagster-cloud-cicd-action/webpack/runtime/define property getters","../webpack://dagster-cloud-cicd-action/webpack/runtime/hasOwnProperty shorthand","../webpack://dagster-cloud-cicd-action/webpack/runtime/make namespace object","../webpack://dagster-cloud-cicd-action/webpack/runtime/compat","../webpack://dagster-cloud-cicd-action/./src/index.js"],"sourcesContent":["const {GraphQLClient, gql} = require('graphql-request');\n\n\n\nconst LIST_LOCATION_QUERY = gql`\nquery WorkspaceEntries {\n    workspace {\n        workspaceEntries {\n            locationName\n            serializedDeploymentMetadata\n        }\n    }\n}\n`;\n\nconst ADD_LOCATION_MUTATION = gql`\nmutation ($location: LocationSelector!) {\n  addLocation(location: $location) {\n     __typename\n     ... on WorkspaceEntry {\n       locationName\n     }\n     ... on PythonError {\n       message\n       stack\n     }\n  }\n}\n`;\n\nconst UPDATE_LOCATION_MUTATION = gql`\nmutation ($location: LocationSelector!) {\n  updateLocation(location: $location) {\n     __typename\n     ... on WorkspaceEntry {\n       locationName\n     }\n     ... on PythonError {\n       message\n       stack\n     }\n  }\n}\n`;\n\nexport class DagsterCloudClient {\n  constructor(url, token) {\n    this.url = url;\n    this.token = token;\n\n    this.gqlClient = new GraphQLClient(url, {\n      headers: {\n        \"Dagster-Cloud-Api-Token\": token,\n      },\n    });\n  }\n\n  async updateLocation(location) {\n    const locationList = await this.gqlClient.request(LIST_LOCATION_QUERY);\n    const locationNames = locationList.workspace.workspaceEntries.map(entry => entry.locationName);\n\n    let result;\n    if (!locationNames.includes(location.name)) {\n      result = (await this.gqlClient.request(ADD_LOCATION_MUTATION, {\n        \"location\": location\n      })).addLocation;\n    } else {\n      result = (await this.gqlClient.request(UPDATE_LOCATION_MUTATION, {\n        \"location\": location\n      })).updateLocation;\n    }\n\n    if (result.__typename === \"PythonError\") {\n      throw new Error(result.message);\n    }\n\n    return result.locationName;\n  }\n}",null,"module.exports = require(\"fs\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\nconst exec = require('@actions/exec');\nconst github = require('@actions/github');\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst util = require('util');\nconst YAML = require('yaml');\nconst {DagsterCloudClient} = require('./dagsterCloud');\n\nconst writeFileAsync = util.promisify(fs.writeFile);\n\nasync function inParallel(locations, processingFunction) {\n  await Promise.all(Object.entries(locations).map(processingFunction));\n}\n\nasync function inSeries(locations, processingFunction) {\n  for (const location of locations) {\n    await processingFunction(location);\n  }\n}\n\nfunction tmpDir() {\n  return fs.mkdtempSync(path.join(os.tmpdir(), 'dagster-cloud-ci'));\n}\n\nasync function writeRequirementsDockerfile(baseImage) {\n  const dockerfilePath = path.join(tmpDir(), 'Dockerfile');\n  await writeFileAsync(dockerfilePath, `\nFROM ${baseImage}\n\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\n\nWORKDIR /opt/dagster/app\n\nCOPY . /opt/dagster/app\n  `);\n  return dockerfilePath;\n}\n\nasync function run() {\n  try {\n    const imageTag = core.getInput('image-tag') || github.context.sha.substring(0, 6);\n\n    const locationFile = core.getInput('location-file');\n\n    const locations = await core.group('Read locations.yaml', async () => {\n      const locationsFile = fs.readFileSync(locationFile, 'utf8');\n      return YAML.parse(locationsFile).locations;\n    }).catch(error => {\n      core.error(`Error reading locations.yaml: ${error}`, file = locations);\n    });\n\n    const parallel = core.getBooleanInput('parallel');\n    const process = parallel ? inParallel : inSeries;\n\n    await core.group('Build Docker images', async () => {\n      await process(locations, async ([_, location]) => {\n        const basePath = path.parse(locationFile).dir;\n        const buildPath = path.join(basePath, location['build']);\n\n        let dockerfile = path.join(buildPath, 'Dockerfile');\n        const baseImage = location['base_image'];\n\n        if (!fs.existsSync(dockerfile)) {\n          const requirementsFile = path.join(buildPath, 'requirements.txt');\n\n          if (!fs.existsSync(requirementsFile) || !baseImage) {\n            core.error(\"Supplied build path must either contain Dockerfile, or requirements.txt with base_image\");\n          }\n\n          dockerfile = await writeRequirementsDockerfile(baseImage);\n        } else {\n          if (baseImage) {\n            core.error(\"No need to specify base_image for location if build path contains Dockerfile\");\n          }\n\n          dockerfile = './Dockerfile';\n        }\n\n        const imageName = `${location['registry']}:${imageTag}`;\n\n        await exec.exec('docker',\n          [\n            'build', '.',\n            '--label', `sha=${github.context.sha}`,\n            '-f', dockerfile,\n            '-t', imageName\n          ],\n          options = {'cwd': buildPath}\n        );\n      });\n    });\n\n    await core.group('Push Docker image', async () => {\n      await process(locations, async ([_, location]) => {\n        const imageName = `${location['registry']}:${imageTag}`;\n        await exec.exec('docker', ['push', imageName]);\n      });\n    });\n\n    await core.group('Update workspace locations', async () => {\n      const dagitUrl = core.getInput('dagit-url');\n      const endpoint = `${dagitUrl}/graphql`\n\n      const apiToken = core.getInput('api-token');\n\n      const client = new DagsterCloudClient(endpoint, apiToken);\n\n      await process(locations, async ([locationName, location]) => {\n        const pythonFile = location['python_file'];\n        const packageName = location['package_name'];\n        if (!(pythonFile || packageName) || (pythonFile && packageName)) {\n          core.error(`Must provide exactly one of python_file or package_name on location ${locationName}.`)\n        }\n\n        // Optionally include some experimental git data in the location metadata\n        // used for some rich linking UI\n        const includeGitData = core.getBooleanInput('experimental-git-data');\n        const sha = github.context.sha;\n        const shortSha = sha.substr(0, 6);\n        const url = `https://github.com/${github.context.repo.owner}/`\n          + `${github.context.repo.repo}/tree/${shortSha}/${location['build']}`;\n\n        const locationData = {\n          name: locationName,\n          image: `${location['registry']}:${imageTag}`,\n          pythonFile: pythonFile,\n          packageName: packageName,\n          sha: includeGitData ? sha : undefined,\n          url: includeGitData ? url : undefined\n        }\n\n        const result = await client.updateLocation(locationData);\n        core.info(`Successfully updated location ${result}`);\n      });\n    });\n\n  } catch (error) {\n    core.setFailed(error.message);\n  }\n}\n\nrun();"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;AC9EA;;;A;;;;;AAAA;;;A;;;;;AAAA;;;A;;;;;AAAA;;;A;;;;;AAAA;;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;;;ACAA;;A;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}